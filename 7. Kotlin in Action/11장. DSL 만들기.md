# **11장. DSL 만들기**

## **11.1 API에서 DSL로**

- 라이브러리를 만드는 개발자를 포함해 모든 개발자는 API를 훌륭하게 만들기 위해 노력해야 함.
- 라이브러리가 외부 사용자에게 프로그래밍 API를 지원하는 것처럼 애플리케이션 안의 모든 클래스는 다른 클래스에게 자신과 상호작용할 수 있는 가능성을 제공함.
- 깔끔한 API의 의미
  - 이름을 잘 붙이고 적절한 개념 사용
  - 코드의 간결성

```kotlin
// 하루 전 날을 반환
val yesterday = 1.days.ago

// HTML 표 생성
fun createSimpleTable() = createHTML().
    table {
        tr {
            td { +"cell" }
        }
    }
```

### **11.1.1 영역 특화 언어라는 개념**

- 범용 프로그래밍 언어
  - 다양한 도메인의 소프트웨어를 개발하기 위해 설계된 프로그래밍 언어
- 영역 특화 언어 (DSL)

  - 특정 과업 또는 영역에 초점을 맞추고 그 영역에 필요하지 않은 기능을 없앤 언어
  - ex) SQL - 데이터베이스 조작에 적합, 정규식 - 문자열 조작에 적합

- DSL의 장점
  - 압축적인 문법을 사용함으로써 범용 언어를 사용하는 것보다 특정 영역에 대한 연산을 더 간결하게 기술할 수 있음.
  - 범용 프로그래밍 언어는 보통 명령적이지만 DSL은 선언적임.
    - 명령적 언어는 어떤 연산을 완수하기 위해 필요한 각 단계를 순서대로 정확히 기술해야 함.
      <br>➡️ 각 연산에 대한 구현을 독립적으로 최적화해야 함.
    - 선언적 언어는 원하는 결과를 기술하기만 하고 그 결과를 달성하기 위해 필요한 세부 실행은 언어를 해석하는 엔진에게 맡김.
    - <br>➡️ 실행 엔진이 전체 과정을 한꺼번에 최적화해 더 효율적임.
- DSL의 단점

  - 범용 언어로 만든 호스트 애플리케이션과 함께 조합하기 어려움.

- 이러한 단점을 해결하면서 DSL의 다른 이점을 살리는 방법으로 내부 DSL이 있음.

<br>

### **11.1.2 내부 DSL**

- 독립적인 문법 구조를 가진 외부 DSL과는 반대로 내부 DSL은 범용 언어로 작성된 프로그래밍의 일부며, 범용 언어와 동일한 문법을 사용함.

```sql
-- 외부 DSL (SQL)
SELECT Country.name, COUNT(Customer.id)
  FROM Country
  JOIN Customer
    ON Country.id = Customer.country_id
GROUP BY Country.name
ORDER BY COUNT(Customer.id) DESC
  LIMIT 1
```

```kotlin
// 내부 DSL (exposed)
(Country join Customer)
  .slice(Country.name, Count(Customer.id))
  .selectAll()
  .groupBy(Country.name)
  .orderBy(Count(Customer.id), isAsc = false)
  .limit(1)
```

- 위 코드는 어떤 구체적인 과업을 달성하기 위한 것이지만(외부 DSL의 특징), 범용 언어(코틀린)의 라이브러리로 구현됨.

<br>

### **11.1.3 DSL의 구조**

- 일반 API (명령-질의 API)
  - 전형적인 라이브러리는 여러 메서드로 이루어지며, 클라이언트는 그런 메서드를 한 번에 하나씩 호출하면서 사용함.
  - 함수 호출 시퀸스에는 아무런 구조가 없으며, 한 호출과 다른 호출 사이에는 아무 맥락도 존재하지 않음.
- DSL
  - 람다를 중첩시키거나 메서드 호출을 연쇄하는 방식으로 구조를 만듦.
  - 여러 함수 호출을 조합해서 연산을 만들며, 타입 검사기는 여러 함수 호출이 바르게 조합됐는지를 검사함.

```gradle
// 코틀린 DSL
dependencies {
  compile("junit:junit:4.11")
  compile("com.google.inject:guice:4.1.0")
}

// 명령-질의 API
project.dependencies.add("compile", "junit:junit:4.11")
project.dependencies.add("compile", "com.google.inject:guice:4.1.0")
```

- DSL 구조의 장점은 같은 문맥을 함수 호출 시마다 반복하지 않고도 재사용할 수 있음.
  <br>➡️ 람다 중첩

```kotlin
// 코틀린 DSL (Kotlin Test)
str should startWith("kot")

// 명령-질의 API (JUnit)
assertTrue(str.startsWith("kot"))
```

<br>

### **11.1.4 내부 DSL로 HTML 만들기**

```kotlin
fun createSimpleTable() = createHTML().
  table {
    tr {
      td { +"cell" }
    }
  }
```

```html
<table>
  <tr>
    <td>cell</td>
  </tr>
</table>
```

- createSimpleTable 함수는 위 HTML 조각이 들어있는 문자열을 반환함.

- 직접 HTML 텍스트를 작성하는 대신 코틀린으로 HTML을 만드는 이유
  - 타입 안전성 보장
    - ex) td를 tr 안에서 사용했는지 체크
  - 표를 정의하면서 동적으로 표의 칸을 생성할 수 있음.

```kotlin
fun createSimpleTable() = createHTML().table {
  val numbers = mapOf(1 to "one", 2 to "two")
  for ((num, string) in numbers) {
    tr {
      td { +"$num" }
      td { +"$string" }
    }
  }
}
```

```html
<table>
  <tr>
    <td>1</td>
    <td>one</td>
  </tr>
  <tr>
    <td>2</td>
    <td>two</td>
  </tr>
</table>
```

<br>
<br>

## **11.2 구조화된 API 구축: DSL에서 수신 객체 지정 DSL 사용**

### **11.2.1 수신 객체 지정 람다와 확장 함수 타입**

```kotlin
// 람다를 인자로 받는 buildString() 정의하기

fun buildString(
  builderAction: (StringBuilder) -> Unit
): String {
  val sb = StringBuilder()
  builderAction(sb)
  return sb.toString()
}

val s = buildString {
  it.append("Hi, ")
  it.append("Kotlin")
}

println(s)    // Hi, Kotlin
```

- 파라미터 타입이 일반 함수 타입임.
  - (StringBuilder) -> Unit
- 람다 본문에서 매번 it을 사용해 StringBuilder 인스턴스를 참조해야 한다는 단점이 있음.

```kotlin
// 수신 객체 지정 람다를 사용해 정의

fun buildString(
  builderAction: StringBuilder.() -> Unit
): String {
  val sb = StringBuilder()
  sb.builderAction()
  return sb.toString()
}

val s = buildString {
  append("Hi, ")
  append("Kotlin")
}

println(s)    // Hi, Kotlin
```

- 파라미터가 확장 함수 타입임.
  - StringBuilder.() -> Unit
- 람다 본문에서는 this를 사용해 수신 객체에 접근할 수 있음. 혹은 this 생략 가능.

```kotlin
// 수신 객체 지정 람다를 변수에 저장하기

val appendExcl: StringBuilder.() -> Unit =
  { this.append("!") }
val sb = StringBuilder("HI")
sb.appendExcl()
println(sb)    // HI!
println(buildString(appendExcl))    // !
```

- appendExcl은 확장 함수 타입의 값임.

```kotlin
// 표준 라이브러리의 buildString()

fun buildString(builderAction: StringBuilder.() -> Unit): String =
  StringBuilder().apply(builderAction).toString()
```

- apply 함수는 인자로 받은 람다나 함수를 호출하면서 자신의 수신 객체를 람다나 함수의 묵시적 수신 객체로 사용함.

```kotlin
inline fun <T> T.apply(block: T.() -> Unit): T {
  block()    // this.block()과 같음.
  return this    // 수신 객체를 반환함.
}

inline fun <T, R> with(receiver: T, block: T.() -> Unit): R =
  receiver.block()    // 람다를 호출해 얻은 결과를 반환함.
```

- apply와 with 모두 자신이 제공받은 수신 객체로 확장 함수 타입의 람다를 호출함.
- apply는 수신 객체 타입에 대한 확장 함수로 선언됐기 때문에 수신 객체를 묵시적 인자(this)로 받음.

```kotlin
val map = mutableMapOf(1 to "one")
map.apply { this[2] = "two" }
map.apply { this[3] = "three" }
println(map)    // {1=one, 2=two, 3=three}
```

- 결과를 받아서 쓸 필요가 없다면 두 함수를 서로 바꿔쓸 수 있음.

<br>

### **11.2.2 수신 객체 지정 람다를 HTML 빌더 안에서 사용**

- HTML 빌더
  - HTML을 만들기 위한 코틀린 DSL

```kotlin
// 코틀린 HTML 빌더를 사용해 간단한 HTML 표 만들기

fun createSimpleTable() = createHTML().
  table {
    tr {
      td { +"cell" }
    }
  }
```
- 위 코드는 일반 코틀린 코드로 table, tr, td 등은 모두 평범한 함수임.
- 각 함수는 고차 함수로 수신 객체 지정 람다를 인자로 받음. 
  - 고차 함수: 람다를 인자로 받거나 반환하는 함수

```kotlin
// HTML 빌더를 위한 태그 클래스 정의

open class Tag

class TABLE: Tag {
  fun tr(init: TR.() -> Unit)
}
class TR: Tag {
  fun td(init: TD.() -> Unit)
}
class TD: Tag
```


<br>

### **11.2.3 코틀린 빌더: 추상화와 재사용을 가능하게 하는 도구**

<br>
<br>

## **리뷰**

### **느낀점**

- 11.1.3 파트에 따르면 전형적인 라이브러리에서 한 메서드를 호출하고 다른 메서드를 호출하는 사이에는 아무 맥락도 존재하지 않음. 또한, 코틀린 DSL에서는 보통 람다를 중첩시키거나 메서드 호출을 연쇄시키는 방식으로 구조를 만든다고 나옴.
  - sequence나 stream은 메서드를 연쇄적으로 호출해 사용할 수 있고, 각 호출 사이에 맥락(규칙)이 존재한다는 점에서 내부 DSL이라고 할 수 있지 않나?
  - https://stackoverflow.com/questions/72685852/is-sequence-referred-to-internal-dsl-in-kotlin

<br>

### **보충**

- ...
