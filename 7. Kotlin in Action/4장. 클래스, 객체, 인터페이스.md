# **4장. 클래스, 객체, 인터페이스**

<br>

## **4.1 클래스 계층 정의**

---

### **4.1.1 코틀린 인터페이스**

```
// 인터페이스 선언

interface Clickable {
    fun click()    // 추상 메서드
    fun showOff() = println("I'm clickable!")    // 디폴트 구현이 있는 메서드
}

interface Focusable {
    fun setFocus(b: Boolean) = println("I ${if(b) "got" else "lost"} focus.")
    fun showOff() = println("I'm focusable!")
}
```

- 코틀린 인터페이스 안에는 추상 메서드 뿐만 아니라 구현이 있는 메서드(자바 8의 디폴트 메서드와 비슷)도 정의할 수 있음. 자바 8과 달리 default와 같은 키워드를 붙일 필요 없음.
- 코틀린 인터페이스에는 아무런 상태(필드)도 들어갈 수 없음.
- Clickable 인터페이스를 구현하는 모든 구체 클래스는 click에 대한 구현을 제공해야 함.
- Clickable 인터페이스를 구현하는 구체 클래스는 showOff 메서드의 새로운 동작을 정의할 수도 있고, 그냥 정의를 생략해 디폴트 구현을 사용할 수도 있음.

```
// 인터페이스 구현

class Button: Clickable, Focusable {
    override fun click() = println("I was clicked.")
    override fun showOff() {
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}

val button = Button()
println(button.click())    // I was clicked.
println(button.showOff())    // I'm clickable!\nI'm focusable!
println(button.setFocus(true))    // I got focus.
```

- 코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리함.
- 자바와 마찬가지로 클래스는 인터페이스를 원하는 만큼 제한 없이 구현할 수 있으나 클래스는 오직 하나만 확장할 수 있음.
- 코틀린에서는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메서드를 오버라이드할 때 꼭 override 변경자를 사용해야 함.
- 이름과 시그니처가 같은 멤버 메서드에 대해 둘 이상의 디폴트 구현이 있는 경우 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야 함.
  <br>➡️ Button 클래스는 동일한 이름, 시그니처의 디폴트 메서드(showOff)를 가진 두 개의 인터페이스 구현하고 있기 때문에, 두 상위 인터페이스에 정의된 showOff 구현을 대체할 오버라이딩 메서드를 직접 제공해야 함.

  ```
  /* Java */
  // 코틀린과 동일하게 이름과 시그니처가 같은 멤버 메서드에 대해 둘 이상의 디폴트 구현이 있는 경우 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야 함.
  // https://webfirewood.tistory.com/130

  public interface Student {
      default String getGreetingMessage() {
          return "Hi, I'm student!";
      }
  }

  public interface Citizen {
      default String getGreetingMessage() {
          return "Hi, I'm citizen!";
      }
  }

  public class Emily implements Student, Citizen {
      @Override
      public String getGreetingMessage() {
          return Student.super.getGreetingMessage();
      }
  }

  Emily emily = new Emily();
  System.out.println(emily.getGreetingMessage())    // Hi, I'm student!
  ```

- 상위 타입의 이름을 꺾쇠 괄호(<>) 사이에 넣어서 "super"를 지정하면 어떤 상위 타입의 멤버 메서드를 호출할지 지정할 수 있음.
- 자바 6은 인터페이스의 디폴트 메서드를 지원하지 않기 때문에 코틀린의 디폴트 메서드 구현에 의존할 수 없음. (p.146)

<br>

### **4.1.2 open, final, abstract 변경자: 기본적으로 final**

- 자바에서는 final로 명시적으로 상속을 금지하지 않는 모든 클래스를 다른 클래스가 상속할 수 있지만 <span style="background-color: purple">코틀린의 클래스와 메서드는 기본적으로 final임.</span>
  - 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킴. [오브젝트]
  - 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라. [이펙티브 자바]

```
open class RichButton: Clickable {    // open. 다른 클래스가 상속 가능.
    fun disable() {}    // final. 하위 클래스는 이 메서드 오버라이드 불가.
    open fun animate() {}    // open. 하위 클래스는 이 메서드 오버라이드 가능.
    override fun click() {}    // open. 오버라이드한 메서드는 기본적으로 열려 있음.
}
```

- 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 함. 또한, 오버라이드를 허용하고 싶은 메서드나 프로퍼티 앞에도 open 변경자를 붙여야 함.

```
// 오버라이드 금지하기

open class RichButton: Clickable {
    final override fun click() {}
}
```

- 기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 그 메서드는 기본적으로 열려 있음.
  <br>➡️ 오버라이드하는 메서드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메서드 앞에 final을 명시해야 함.

```
// 추상 클래스 정의하기

abstract class Animated {
    abstract fun animate()    // 추상 함수. 하위 클래스는 반드시 이 함수를 오버라이드 해야함.
    open fun stopAnimating() {    // open으로 하위 클래스의 오버라이드 허용
        ...
    }
    fun animateTwice() {    // final
        ...
    }
}
```

- 추상 클래스는 인스턴스화 할 수 없으며, 추상 멤버는 항상 open임.
  <br>➡️ 추상 멤버 앞에 open 변경자를 명시할 필요가 없음.
- 추상 클래스에 속한 비추상 함수는 기본적으로 final임.

<br>

- 클래스 내에서 상속 제어 변경자의 의미

  | 변경자 | 이 변경자가 붙은 멤버는... | 설명 |
  | :----- | :------------------------- | :--- |
  | -      | -                          | -    |

<br>
<br>
<br>
<br>

<br>
<br>

## **3.2 함수를 호출하기 쉽게 만들기**

---

<br>
<br>

## **리뷰**

---

### **느낀점**

- 자바도 공부 다시 해야하지 않을까... 겁나 헷갈리네...
- 헷갈리는 부분
  - 코틀린의 인터페이스에 디폴트 구현이 있는 메서드는 기본적으로 open이고 코틀린의 추상 클래스의 디폴트 메서드는 기본적으로 final이다.

<br>

### **궁금한 점**

1. ...
