# **7장. 연산자 오버로딩과 기타 관례**

- 관례란?

  - 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법
  - ex) 어떤 클래스 안에 plus라는 이름의 특별한 메서드를 정의하면 그 클래스의 인스턴스에 대해 + 연산자를 사용할 수 있음.

- 언어 기능을 타입에 의존하는 자바와 달리 코틀린은 (함수 이름을 통한) 관례에 의존함.

## **7.1 산술 연산자 오버로딩**

> 코틀린에서 관례를 사용하는 가장 단순한 예인 산술 연산자

- 자바에서는 원시 타입에 대해서만 산술 연산자를 사용할 수 있고, 추가로 String에 대해 + 연산자를 사용할 수 있음.
- 그러나 다른 클래스에서도 산술 연산자가 유용한 경우가 있음.
  - ex) BigInteger 클래스에서 add 메서드를 명시적으로 호출하기보다는 + 연산 사용

### **7.1.1 이항 산술 연산 오버로딩**

```
// 연산자를 멤버 함수로 정의하기

data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point) : Point {
        return Point(x + other.x, y + other.y)
    }
}

val p1 = Point(10, 20)
val p2 = Point(30, 40)
println(p1 + p2)    // Point(x=40, y=60)
```

- operator 키워드
  - 연산자를 오버로딩하는 함수 앞에 필수적으로 붙여야 하는 키워드

```
// 연산자를 확장 함수로 정의하기

operator fun Point.plus(other: Point) : Point {
    return Point(x + other.x, y + other.y)
}
```

> 외부 함수의 클래스에 대한 연산자를 정의할 때는 관례에 따르는 이름의 확장 함수로 구현하는 것이 일반적인 패턴

- 오버로딩 가능한 이항 산술 연산자

  |   식   | 함수 이름 |
  | :----: | :-------: |
  | a \* b |   times   |
  | a / b  |    div    |
  | a % b  |    mod    |
  | a + b  |   plus    |
  | a - b  |   minus   |

- 연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선순위와 같음.

<br>

```
// 두 피연산자의 타입이 다른 연산자 정의하기

operator fun Point.times(scale: Double) : Point {
    return Point((x * scale).toInt(), (y * scale).toInt())
}

val p = Point(10, 20)
println(p * 1.5)    // Point(x=15, y=30)
```

- 연산자를 정의할 때 두 피연산자가 같은 타입일 필요는 없음.

```
println(1.5 * p)    // Error!
```

- 코틀린 연산자가 자동으로 교환 법칙을 지원하지 않음.따라서 위처럼 사용하려면 아래의 연산자 함수를 정의해야 함.

```
operator fun Double.times(p: Point) : Point { ... }
```

<br>

```
// 결과 타입이 피연산자 타입과 다른 연산자 정의하기

operator fun Char.times(count: Int) : String {
    return toString().repeat(count)
}

println('a' * 3)    // aaa
```

- 연산자 함수의 반환 타입이 두 피연산자와 일치할 필요가 없음.
- 일반 메서드의 본문에서 this를 사용할 때와 마찬가지로 확장 함수 본문에도 this를 생략할 수 있음. (3.3절)

<br>

- 일반 함수와 마찬가지로 operator 함수도 오버로딩 할 수 있음.

<br>

### **7.1.2 복합 대입 연산자 오버로딩**

- 복합 대입 연산자
  - ex) +=, -=

```
var point = Point(1, 2)
point += Point(3, 4)
println(point)    // Point(4, 6)
```

- point += Point(3, 4)는 point = point + Point(3, 4)와 동일함.
- 따라서 point 객체에는 두 점의 좌표 성분을 더한 값을 성분으로 하는 새로운 Point 객체를 반환함.

```
val numbers = ArrayList<Int>()
numbers += 42
println(numbers[0])    // 42
```

- += 연산이 객체에 대한 참조를 다른 참조로 바꾸는 것이 아닌 원래 객체의 내부 상태를 변경할 수도 있음.
- 반환 타입이 Unit인 plusAssign 함수를 정의하면 코틀린은 += 연산자에 그 함수를 사용함.
  ```
  operator fun <T> MutableCollection<T>.plusAssign(element: T) {
      this.add(element)
  }
  ```

```
a += b

(1) a = a + b    // plus
(2) a.plusAssign(b)    // plusAssign
```

- 이론적으로 코드에 있는 +=를 plus와 plusAssign 양쪽으로 컴파일 할 수 있음.
- 어떤 클래스가 이 두 함수를 모두 정의하고 둘 다 +=에 사용 가능한 경우 컴파일러는 오류를 보고함.

> plus와 plusAssign을 동시에 정의하지 말아라

- 코틀린에서 컬렉션에 대해 제공하는 접근 방법
  - +, -
    - 항상 새로운 컬렉션을 반환함.
  - +=, -=
    - 변경 가능한 컬렉션에서는 메모리에 있는 객체 상태를 변화시킴.
    - 읽기 전용 컬렉션에서는 변경을 적용한 복사본을 반환함.

```
val list = arrayListOf(1, 2)
list += 3
val newList = list + listOf(4, 5)
println(list)    // [1, 2, 3]
println(newList)    // [1, 2, 3, 4, 5]
```

- +=는 "list"의 상태를 변경함.
- +는 두 리스트의 모든 원소를 포함하는 새로운 리스트를 반환함.

<br>

### **7.1.3 단항 연산자 오버로딩**

```
operator fun Point.unaryMinus(): Point {
    return Point(-x, -y)
}

val p = Point(10, 20)
println(-p)    // Point(x=-10, y=-20)

```

- 오버로딩 가능한 단항 산술 연산자

  |    식    | 함수 이름  |
  | :------: | :--------: |
  |    +a    | unaryPlus  |
  |    -a    | unaryMinus |
  |    !a    |    not     |
  | a++, ++a |    inc     |
  | a--, --a |    dec     |

```
// 증가 연산자 정의하기

operator fun BigDecimal.inc() = this + BigDecimal.ONE

var bd = BigDecimal.ZERO
println(bd++)    // 0
println(++bd)    // 2
```

- 후위 증가 연산자는 println이 실행된 뒤에 bd의 값을 증가시킴.
- 전위 증가 연산자는 println이 실행되기 전에 bd의 값을 증가시킴.

<br>
<br>

## **7.2 비교 연산자 오버로딩**

### **7.2.1 동등성 연산자: equals**

```
a == b
a?.equals ?: (b == null)
```

- 동등성 검사 ==는 equals 호출과 널 검사로 컴파일됨.
- 따라서 널이 될 수 있는 값에도 적용할 수 있음.

```
class Point(val x: Int, val y: Int) {
    override fun equals(obj: Any?): Boolean {
        if (obj === this) return true
        if (obj !is Point) return false
        return obj.x == x && obj.y == y
    }
}

println(Point(10, 20) == Point(10, 20))    // true
println(Point(10, 20) != Point(5, 5)) // true
println(null == Point(1, 2))    // false
```

- 식별자 비교 연산자(===)

  - 두 피연산자가 서로 같은 객체를 가리키는지(원시 타입인 경우 두 값이 같은지) 비교함.

- 다른 연산자 오버로딩 관례와 달리 equals는 Any에 정의된 메서드이므로 override가 필요함.
  - 또한, Any의 equals에 operator가 붙어 있기 때문에 이를 오버라이드하는 하위 메서드 앞에는 붙이지 않아도 됨.
- Any에서 상속 받은 equals가 확장 함수보다 우선순위가 높기 때문에 equals를 확장 함수로 정의할 수 없음.
- 스마트 캐스트가 적용됨.

<br>

### **7.2.2 순서 연산자: compareTo**

- 자바에서 정렬이나 최댓값, 최솟값 등 값을 비교해야 하는 알고리즘 클래스는 Comparable 인터페이스를 구현해야 함.
  - Comparable의 compareTo 메서드는 한 객체와 다른 객체의 크기를 비교해 정수로 나타내줌.
  - 그러나 자바에는 이 메서드를 짧게 호출할 수 있는 방법이 없음.
- 코틀린에서도 동일한 Comparable 인터페이스를 지원하지만 compareTo 메서드를 호출하는 관례를 제공함.
  ```
  a >= b
  a.compareTo(b) >= 0
  ```

```
class Person(val firstName: String, val lastName: String): Comparable<Person> {
    override fun compareTo(other: Person): Int {
        return compareValuesBy(this, other, Person::lastName, Person::firstName)
    }
}

val p1 = Person("Alice", "Smith")
val p2 = Person("Bob", "Johnson")
println(p1 < p2)    // false
```

- equals와 마찬가지로 Comparable의 compareTo에도 operator 변경자가 붙어 있으므로 하위 클래스의 오버라이딩 함수에 operator를 붙일 필요 X
- compareValuesBy 메서드
  - 두 객체와 여러 비교 함수를 인자로 받음.
  - 첫 번째 비교 함수에 두 객체를 넘겨 두 객체가 같지 않다는 결과(0이 아닌 값)가 나오면 그 결과 값을 즉시 반환하고, 두 객체가 같다는 결과(0)가 나오면 두 번째 비교 함수를 통해 두 객체를 비교함.

```
println("abc" < "bac")
```

- Comparable 인터페이스를 구현하는 모든 자바 클래스를 코틀린에서는 간결한 연산자 구문으로 비교할 수 있음.

<br>

> 처음에는 성능에 신경쓰지 말고 이해하기 쉽고 간결하게 코드를 작성하고, 나중에 그 코드가 자주 호출됨에 따라 성능이 문제가 되면 성능을 개선하라

<br>
<br>

## **7.4 구조 분해 선언과 component 함수**

- ...

### **7.4.1 구조 분해 선언과 루프**

<br>
<br>

## **리뷰**

### **느낀점**

- ...

<br>

### **보충**

- 백준 11651 좌표 정렬하기 2 문제에서 두 Point 객체를 비교할 때 compareTo를 오버라이드 한 것이 아닌 compare 메서드를 구현함. compareTo 메서드를 구현하면 시간이 더 오래 걸리려나?
  - ...
