# **10장. 애노테이션과 리플렉션**

## **10.1 애노테이션 선언과 적용**

- 메타데이터를 선언에 추가하면 애노테이션을 처리하는 도구가 컴파일 시점이나 실행 시점에 적절한 처리를 해줌.

### **10.1.1 애노테이션 적용**

```kotlin
@Deprecated("Use removeAt(index) instead.", ReplaceWith("removeAt(index)"))
fun remove(index: Int) { ... }
```

- 애노테이션의 인자로는 원시 타입의 값, 문자열, enum, 클래스 참조, 다른 애노테이션 클래스, 앞의 요소들로 이루어진 배열이 들어갈 수 있음.
- 클래스를 애노테이션의 인자로 지정할 때는 @MyAnnotation(MyClass::class)와 같이 사용해야 함.
- 다른 애노테이션을 인자로 지정할 때는 인자로 들어가는 애노테이션의 이름 앞에 @를 넣지 않아야 함.
  - 위 예제에서 ReplaceWith도 애노테이션이지만 Deprecated 인자로 들어갈 때 @를 사용하지 X
- 배열을 인자로 지정하려면 @RequestMapping(path=arrayOf("/foo", "/bar"))처럼 arrayOf 함수를 사용함.

```kotlin
const val TEST_TIMEOUT = 100L

@Test(timeout = TEST_TIMEOUT) fun testMethod() { ... }
```

- 애노테이션 인자를 컴파일 타임에 알 수 있어야 함.
  <br>➡️ 프로퍼티를 애노테이션 인자로 사용하려면 앞에 const 변경자를 붙여야 함.

<br>

### **10.1.2 애노테이션 대상**

- 코틀린 소스코드에서 한 선언을 컴파일한 결과가 여러 자바 선언과 대응하는 경우가 자주 있음.
  - ex) 코틀린의 읽기 전용 프로퍼티는 자바 필드와 게터 메서드에 대응함.
- 사용 지점 대상 선언
  - 애노테이션을 붙일 요소를 정할 수 있음.
  - property
    - 프로퍼티 전체
  - field
    - 프로퍼티에 의해 생성되는(뒷받침하는) 필드
  - get
    - 프로퍼티 게터
  - set
    - 프로퍼티 세터
  - file
    - 파일 안에 선언된 최상위 함수와 프로퍼티를 담아두는 클래스

```kotlin
// 사용 지점 대상 지정 문법

@get:Rule
```

- Rule 애노테이션을 프로퍼티 게터에 적용하라는 의미임.

```kotlin
@file:JvmName("StringFunctions")
package strings
fun joinToString(...): String { ... }
```

```java
import strings.StringFunctions;
StringFunctions.joinToString(list, ", ", "", "");
```

- file 대상을 사용하는 애노테이션은 package 선언 앞에서 파일의 최상위 수준에만 적용할 수 있음.
- 위 예제에서는 @JvmName을 사용해 클래스의 이름을 바꿔줌.

<br>

### **10.1.3 애노테이션을 활용한 JSON 직렬화 제어**

- ...

<br>
<br>

## **10.2 리플렉션: 실행 시점에 코틀린 객체 내부 관찰**

- ...

### **0.0.0 ...**

<br>
<br>

## **리뷰**

### **느낀점**

- ...

<br>

### **보충**

- ...
