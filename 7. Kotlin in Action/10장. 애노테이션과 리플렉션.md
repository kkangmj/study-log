# **10장. 애노테이션과 리플렉션**

## **10.1 애노테이션 선언과 적용**

- 메타데이터를 선언에 추가하면 애노테이션을 처리하는 도구가 컴파일 시점이나 실행 시점에 적절한 처리를 해줌.

### **10.1.1 애노테이션 적용**

```kotlin
@Deprecated("Use removeAt(index) instead.", ReplaceWith("removeAt(index)"))
fun remove(index: Int) { ... }
```

- 애노테이션의 인자로는 원시 타입의 값, 문자열, enum, 클래스 참조, 다른 애노테이션 클래스, 앞의 요소들로 이루어진 배열이 들어갈 수 있음.
- 클래스를 애노테이션의 인자로 지정할 때는 @MyAnnotation(MyClass::class)와 같이 사용해야 함.
- 다른 애노테이션을 인자로 지정할 때는 인자로 들어가는 애노테이션의 이름 앞에 @를 넣지 않아야 함.
  - 위 예제에서 ReplaceWith도 애노테이션이지만 Deprecated 인자로 들어갈 때 @를 사용하지 X
- 배열을 인자로 지정하려면 @RequestMapping(path=arrayOf("/foo", "/bar"))처럼 arrayOf 함수를 사용함.

```kotlin
const val TEST_TIMEOUT = 100L

@Test(timeout = TEST_TIMEOUT) fun testMethod() { ... }
```

- 애노테이션 인자를 컴파일 타임에 알 수 있어야 함.
  <br>➡️ 프로퍼티를 애노테이션 인자로 사용하려면 앞에 const 변경자를 붙여야 함.

<br>

### **10.1.2 애노테이션 대상**

- 코틀린 소스코드에서 한 선언을 컴파일한 결과가 여러 자바 선언과 대응하는 경우가 자주 있음.
  - ex) 코틀린의 읽기 전용 프로퍼티는 자바 필드와 게터 메서드에 대응함.
- 사용 지점 대상 선언
  - 애노테이션을 붙일 요소를 정할 수 있음.
  - property
    - 프로퍼티 전체
  - field
    - 프로퍼티에 의해 생성되는(뒷받침하는) 필드
  - get
    - 프로퍼티 게터
  - set
    - 프로퍼티 세터
  - file
    - 파일 안에 선언된 최상위 함수와 프로퍼티를 담아두는 클래스

```kotlin
// 사용 지점 대상 지정 문법

@get:Rule
```

- Rule 애노테이션을 프로퍼티 게터에 적용하라는 의미임.

```kotlin
@file:JvmName("StringFunctions")
package strings
fun joinToString(...): String { ... }
```

```java
import strings.StringFunctions;
StringFunctions.joinToString(list, ", ", "", "");
```

- file 대상을 사용하는 애노테이션은 package 선언 앞에서 파일의 최상위 수준에만 적용할 수 있음.
- 위 예제에서는 @JvmName을 사용해 클래스의 이름을 바꿔줌.

<br>

### **10.1.3 애노테이션을 활용한 JSON 직렬화 제어**

- 직렬화
  - 객체를 저장장치에 저장하거나 네트워크를 통해 전송하기 위해 텍스트나 이진 형식으로 변환하는 것
- 역직렬화
  - 텍스트나 이진 형식으로 저장된 데이터로부터 원래의 객체를 만들어내는 것

<img src="https://user-images.githubusercontent.com/52561963/170619082-0faf26ab-46da-44ad-8f1b-5b87bd07f782.png" width="400">

```kotlin
data class Person(val name: String, val age: Int)

val person = Person("Alice", 29)
println(serialize(person))    // {"age": 29, "name": "Alice"}

val json = """{"name": "Alice", "age": 29}"""
println(deserialize<Person>(json))    // Person(name=Alice, age=29)
```

- JSON에는 객체의 타입이 저장되지 않기 때문에 JSON 데이터로부터 인스턴스를 만들려면 타입 인자로 클래스를 명시해야 함.

```kotlin
data class Person(
  @JsonName("alias") val firstName: String,
  @JsonExclude val age: Int? = null
)
```

- @JsonExclude
  - 직렬화나 역직렬화 시 그 프로퍼티를 무시할 수 있음.
  - 대신 반드시 디폴트 값을 지정해야 함.
- @JsonName
  - 프로퍼티를 표현하는 키/값 쌍의 키로 프로퍼티 이름 대신 애노테이션이 지정한 이름을 쓰게 할 수 있음.

<img src="https://user-images.githubusercontent.com/52561963/170619821-9df69057-2af9-4db3-bc16-b91b71ea30cc.png" width="400">

<br>

### **10.1.4 애노테이션 선언**

```kotlin
annotation class JsonExclude
```

- @JsonExclude 애노테이션은 아무 파라미터도 없는 애노테이션
- 코틀린에서 애노테이션 클래스는 오직 선언이나 식과 관련 있는 메타데이터의 구조를 정의하기 때문에 본문을 정의할 수 없음.
- 파라미터가 있는 애노테이션 정의하는 방법
  ```kotlin
  annotation class JsonExclude(val name: String)
  ```
  - 일반 클래스의 주 생성자 선언 구문과 동일함.
  - 애노테이션 클래스에는 모든 파라미터 앞에 val을 붙여야 함.

<br>

### **10.1.5 메타애노테이션: 애노테이션을 처리하는 방법 제어**

- 메타애노테이션
  - 애노테이션 클래스에 적용할 수 있는 애노테이션

```kotlin
@Target(AnnotationTarget.PROPERTY)
annotation class JsonExclude
```

- @Target
  - 애노테이션을 적용할 수 있는 요소의 유형을 지정하는 메타애노테이션

<br>

### **10.1.6 애노테이션 파라미터로 클래스 사용**

- ...

<br>
<br>

## **10.2 리플렉션: 실행 시점에 코틀린 객체 내부 관찰**

- ...

### **0.0.0 ...**

<br>
<br>

## **리뷰**

### **느낀점**

- ...

<br>

### **보충**

- ...
