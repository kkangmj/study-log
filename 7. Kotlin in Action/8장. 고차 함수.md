# **8장. 고차 함수: 파라미터와 반환 값으로 람다 사용**

- 고차 함수
  - 람다를 인자로 받거나 반환하는 함수
  - ex) 5장에서 코틀린 표준 라이브러리가 제공하는 map, with 등의 함수

## **8.1 고차 함수 정의**

### **8.1.1 함수 타입**

```
val sum = { x: Int, y: Int -> x + y }
val action = { println(42) }
```

- 코틀린의 타입 추론으로 변수 타입을 지정하지 않아도 람다를 변수에 대입할 수 있음.

```
// 위 예제에서 각 변수에 구체적인 타입 선언을 추가한 경우

val sum: (Int, Int) -> Int = { x, y -> x + y }
val action: () -> Unit = { println(42) }
```

- 함수 타입을 정의하려면 함수 파라미터의 타입을 괄호 안에 넣고, 그 뒤에 화살표를 추가한 다음, 함수의 반환 타입을 지정하면 됨.

```
// 반환 타입이 널이 될 수 있는 함수 타입
var canReturnNull: (Int, Int) -> Int? = { x, y -> null }

// 함수 타입 전체가 널이 될 수 있는 타입
var funOrNull: ((Int, Int) -> Int)? = null
```

```
// 함수 타입에 파라미터 이름 지정하기

fun performRequest(
    url: String,
    callback: (code: Int, content: String) -> Unit
) { ... }

val url = "http://kotl.in"
performRequest(url) { code, content -> ... }
performRequest(url) { code, page -> ... }
```

- 파라미터 이름이 함수 타입 선언의 파라미터 이름과 일치하지 않아도 됨.

<br>

### **8.1.2 인자로 받은 함수 호출**

```
fun twoAndThree(operation: (Int, Int) -> Int) {
    val result = operation(2, 3)
    return result
}

twoAndThree { a, b -> a + b }    // 5
twoAndThree { a, b -> a * b }    // 6
```

```
// filter 함수를 단순하게 만든 버전 구현하기

fun String.filter(predicate: (Char) -> Boolean): String {
    val sb = StringBuilder()
    for (index in 0 until length) {
        val element = get(index)
        if (predicate(element)) sb.append(element)
    }
    return sb.toString()
}

println("abc1".filter({ it in 'a'..'z' }))    // abc
```

<br>

### **8.1.3 자바에서 코틀린 함수 타입 사용**

- 컴파일된 코드 안에서 함수 타입의 변수는 FunctionN 인터페이스를 구현하는 객체를 저장함. (보충 파트 참고)
- 각 인터페이스에는 invoke 메서드 정의가 들어 있어 이 메서드를 호출하면 함수를 실행할 수 있음.

```
// 함수 타입을 사용하는 코틀린 함수를 자바에서 호출하기

/* KOTLIN */
fun processTheAnswer(f: (Int) -> Int) {
    println(f(42))
}

processTheAnswer { n -> n + 1 }

/* JAVA 8 */
processTheAnswer(n -> n + 1)

/* JAVA 8 이전 */
processTheAnswer(new Function1<Integer, Integer>() {
    @Override
    public Integer invoke(Integer number) {
        System.out.println(number);
        return number + 1;
    }
})
```

- 자바 8에서는 람다를 넘기면 되고, 자바 8 이전의 버전인 경우 FunctionN 인터페이스의 invoke 메서드를 구현하는 무명 클래스를 넘기면 됨.

```
// 자바에서 코틀린 표준 라이브러리가 제공하는 람다를 인자로 받는 확장함수 호출하기

/* JAVA */
List<String> strings = new ArrayList();
strings.add("42")
CollectionsKt.forEach(strings, s -> {
    System.out.println(s);
    return Unit.INSTANCE;
});
```

- 수신 객체를 확장 함수의 첫 번째 인자로 명시적으로 넘겨야 함.
- 확장 함수의 반환 타입이 Unit인 경우 자바에서는 이 값을 명시적으로 반환해야만 함.

<br>

### **8.1.4 디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터**

```
// 함수 타입의 파라미터에 대한 디폴트 값 지정하기

fun <T> Collection<T>.joinToString(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = "",
    transform: (T) -> String = { it.toString() }
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        result.append(transform(element))
    }
    result.append(postfix)
    return result.toString()
}

val letters = listOf("Alpha", "Beta")
println(letters.joinToString())    // Alpha, Beta
println(letters.joinToString { it.toLowerCase() })    // alpha, beta
println(letters.joinToString(seperator = "! ", postfix = "!", transform = { it.toUpperCase() }))    // ALPHA! BETA!
```

- 함수 타입에 대한 디폴트 값 선언은 다른 파라미터의 디폴트 값과 마찬가지로 = 뒤에 람다를 넣으면 됨.

```
// 널이 될 수 있는 함수 타입 파라미터를 사용하기

fun <T> Collection<T>.joinToString(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = "",
    transform: ((T) -> String)? = null
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        result.append(transform?.invoke(element) ?: element.toString())
    }
    result.append(postfix)
    return result.toString()
}
```

- 널이 될 수 있는 함수 타입으로 함수를 받으면 그 함수를 직접 호출할 수 없음.
  - 명시적인 null 검사를 하고 호출
    ```
    fun foo(callback: (() -> Unit)?) {
        // ...
        if (callback != null) {
            callback()
        }
    }
    ```
  - invoke 메서드로 호출
    - b/c 함수 타입이 invoke 메서드를 구현하는 인터페이스임

<br>

### **8.1.5 함수를 함수에서 반환**

```
// 함수를 반환하는 함수 정의하기

enum class Delivery { STANDARD, EXPEDITED }

class Order(val itemCount: Int)

fun getShippingCostCalculator(delivery: Delivery) : (Order) -> Double {
    if (delivery == Delivery.EXPEDITED) {
        return { order -> 6 + 2.1 * order.itemCount }
    }
    return { order -> 1.2 * order.itemCount }
}

val calculator = getShippingCostCalculator(Delivery.EXPEDITED)
println("Shipping costs ${calculator(Order(3))}")    // Shipping costs 12.3
```

<br>

### **8.1.6 람다를 활용한 중복 제거**

<br>
<br>

## **리뷰**

### **느낀점**

- (p.333) 자바 8 버전 이전 예제에서 println 뒤에 number + 1하고 리턴하면 결과값이 42이 아닌가?

  - 아래 코드를 직접 돌려본 결과 42와 43이 콘솔에 출력됨. 왜지...? 아무리 찾아봐도 모르겠음... 자바 버전 8에서 실습해서 그런가?

    <img src="https://user-images.githubusercontent.com/52561963/163943680-6a5acd31-dcf1-4545-ba33-c4a94efe1ef6.png" width="400">

  - 책에 나온 자바 8 버전 예제는 책에 나온 결과값과 동일하게 43만 출력됨.
  - 스터디 후에도 해결되지 않으면 단톡방에 물어보기!

<br>

### **보충**

- FunctionN 인터페이스

    <img src="https://user-images.githubusercontent.com/52561963/163938018-9ef291f7-972e-4b2c-b84f-5391049c937d.png" width="400">

  - 코틀린에서 구현한 고차 함수

    ```
    // test.kt

    fun twoAndThree(operation: (Int, Int) -> Int) {
        val result = operation(2, 3)
        println(result)
    }
    ```

  - 위 코틀린 파일을 디컴파일한 결과

    <img src="https://user-images.githubusercontent.com/52561963/163938472-6d9ccb5a-4c05-460e-aa26-c35f336c6aba.png">
