# **2장. 코틀린 기초**

<br>

### **기본 요소: 함수와 변수**

- 함수를 최상위 수준에 정의할 수 있음.
- System.out.println 대신 println이라고 작성함.
- 줄 끝에 세미콜론(;)을 붙이지 않아도 됨.

```
** 함수 **

// 블록이 본문인 함수
fun max(a: Int, b: Int) : Int {
    return if (a > b) a else b
}
// 식이 본문인 함수
fun max(a : Int, b: Int) = if (a > b) a else b
```

- 코틀린에서는 식이 본문인 함수가 자주 쓰임. 또한, 식이 본문인 함수의 경우 사용자가 필수적으로 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해 식의 결과 타입을 함수 반환 타입으로 정해줌. ➡️ 타입 추론

```
** 변수 **

val answer = 42   // 변수 선언 및 초기화 시 타입을 지정하지 않아도 됨.
val answer: Int = 42

// 그러나, 변수 선언과 초기화가 분리되어 있다면 변수 타입이 명시되어야 함.
val answer: Int
answer = 42

// 변수 선언 시 사용하는 키워드
(1) val - 변경 불가능한 참조를 저장하는 변수. 초기화되고 나면 재대입이 불가함.
(2) var - 변경 가능한 참조. 변수의 값이 변경될 수 있음.
```

- 기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하라.
  - b/c 변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워짐.

```
** 문자열 템플릿 **

fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "kotlin"
    println("Hello $name")
}

fun main(args: Array<String>) {
    println("Hello ${if (args.size > 0) args[0] else "kotlin"}")
}
```

<br>

### **클래스와 프로퍼티**

```
// Java
public class Person {
    private final String name;
    private boolean isMarried;

    public String getName();
    public boolean isMarried();
    public void setIsMarried();
}

// Kotlin
class Person (    // 코틀린의 기본 가시성은 public이기 때문에 가시성 변경자 생략 가능
    val name: String    // 읽기 전용 프로퍼티
    var isMarried: Boolean    // 변경 가능한 프로퍼티
)

// Java
Person person = new Person("Bob", true);
System.out.println(person.getName());    // Bob

// Kotlin
val person = Person("Bob", true)
println(person.name)
```

- 프로퍼티
  - 필드와 접근자(getter, setter)를 통칭
- 자바에서는 디렉터리 구조가 패키지 구조를 그대로 따라야 하지만 코틀린에서는 패키지 구조와 디렉터리 구조가 맞아 떨어질 필요는 없음. 또한, 코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있음.
  - 그러나 대부분의 경우 자바와 같이 패키지별로 디렉터리를 구성하는 편이 나음.

<br>

### **선택 표현과 처리: enum과 when**

```
** enum **
enum class Color (
  val r: Int, val g: Int, val b: Int    // 상수의 프로퍼티 정의
) {
  RED(255, 0, 0), ORANGE(255, 165, 0),
  YELLOW(255, 255, 0), GREEN(0, 255, 0), BLUE(0, 0, 255);

  fun rgb() = (r * 256 + g) * 256 + b
}
```

- enum은 소프트 키워드로 class 키워드 앞에 있을 때만 특별한 의미를 지니기 때문에 다른 곳에서 이름에 enum을 사용할 수 있음.
- enum 클래스 안에 메서드를 정의하는 경우 반드시 enum 상수 목록과 메서드 정의 사이에 세미콜론을 넣어야 함.

```
** when **
fun getWarmth(color: Color) = when (color) {
  Color.RED, Color.ORANGE -> "warm"
  Color.GREEN -> "neutral"
  Color.BLUE -> "cold"
}

println(getWarmth(Color.ORANGE))    // warm

fun mix(cl: Color, c2: Color) =
  when (setOf(c1, c2)) {
    setOf(RED, YELLOW) -> ORANGE
    setOf(YELLOW, BLUE) -> GREEN
    setOf(BLUE, VIOLET) -> INDIGO
    else -> throw Exception("Dirty Color")
  }

println(mix(BLUE, YELLOW))    // GREEN
```

- setOf 함수
  - 인자로 전달받은 여러 객체를 그 객체들을 포함하는 집합인 Set 객체로 만드는 함수

```
// mix()는 분기 조건 검사 시 여러 set 인스턴스를 생성하기 때문에 mix() 함수가 자주 호출되는 경우 불필요한 가비지 객체가 늘어남.
// 따라서, 인자가 없는 when 식을 통해 불필요한 객체의 생성을 없앰.

fun mixOptimized(c1: Color, c2: Color) =
  when {
    (c1 == RED && c2 == YELLOW) ||
    (c1 == YELLOW && c2 == RED) -> ORANGE
    (c1 == YELLOW && c2 == BLUE) ||
    (c1 == BLUE && c2 == YELLOW) -> GREEN
    (c1 == BLUE && c2 == VIOLET) ||
    (c1 == VIOLET && c2 == BLUE) -> INDIGO
    else -> throw Exception("Dirty color")
  }

println(mixOptimized(BLUE, YELLOW))    // GREEN
```

- mixOptimized()는 mix()보다 가독성은 떨어지지만 성능을 향상시키기 위해 그 정도 비용을 감수해야 하는 경우도 자주 있음.

```
** 스마트 캐스트 **
interface Expr    // 아무 메서드도 선언하지 않으며, 공통 타입 역할만 수행
class Num(val value: Int) : Expr    // Num과 Sum 클래스는 Expr 인터페이스 구현
class Sum(val left: Expr, val right: Expr) : Expr

fun eval(e: Expr): Int {
  if (e is Num) {
    return e.value    // 컴파일러가 e의 타입이 Num인지 검사한 후 e의 타입을 Num으로 해석함.
  }
  if (e is Sum) {
    return eval(e.right) + eval(e.left)
  }
  throw IllegalArgumentException("Unknown expression")
}

println(eval(Sum(Sum(Num(1), Num(2)), Num(4))))    // 7
```

- 자바에서 어떤 변수의 타입을 instanceof로 확인한 다음에 그 타입에 속한 멤버에 접근하기 위해서는 명시적으로 변수 타입을 캐스팅해야 함.
- 코틀린에서는 컴파일러가 캐스팅을 해줌. 어떤 변수가 원하는 타입인지 is로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 마치 처음부터 그 변수가 원하는 타입으로 선언된 것처럼 사용할 수 있음. ➡️ 스마트 캐스트
- 원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드 사용
  ```
  val n = e as Num
  ```
