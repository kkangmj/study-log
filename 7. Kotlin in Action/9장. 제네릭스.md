# **9장. 제네릭스**

## **9.1 제네릭 타입 파라미터**

- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있음.
  ```
  // authors가 List<String> 임을 추론함.
  val authors = listOf("Dmitry", "Svetlana")
  ```
- 단, 빈 리스트를 생성하는 경우에는 컴파일러가 추론할 수 있는 근거가 없기 때문에 타입 인자를 직접 명시해야 함.
  ```
  val readers: MutableList<String> = mutableListOf()
  val readers = mutableListOf<String>()
  ```
- 자바는 뒤늦게 제네릭을 도입했기 때문에 이전 버전과의 호환성을 위해 타입 인자가 없는 제네릭 타입(raw 타입)을 허용함.
  ```
  ArrayList list = new ArrayList();    // O
  ArrayList list = new ArrayList<String>();    // O
  ```
- 그러나, 코틀린은 처음부터 제네릭을 도입했기 때문에 로 타입을 지원하지 않고 제네릭 타입의 타입 인자를 항상 정의해야 함.
  ```
  val list = mutableListOf()    // X
  val list = mutableListOf<String>()    // O
  ```

### **9.1.1 제네릭 함수와 프로퍼티**

```
fun <T> List<T>.slice(indices: IntRange): List<T>
```

- 함수의 타입 파라미터 T가 수신 객체와 반환 타입에 사용됨.

```
// 제네릭 함수 호출하기

val letters = ('a'..'z').toList()
println(letters.slice<Char>(0..2))    // [a, b, c]
println(letters.slice(10..13))    // [k, l m, n]
```

- 타입 인자를 명시적으로 지정할 수 있음. 그러나 컴파일러가 대부분 타입 인자를 추론할 수 있으므로 굳이 지정하지 않아도 됨.
- 컴파일러는 slice 함수의 반환 타입 List\<T>의 T를 자신이 추론한 Char로 치환함.

```
// 제네릭 고차 함수 호출하기

val authors = listOf("Dmitry", "Svetlana")
val readers = mutableListOf<String>(...)

fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>

readers.filter { it !in authors }
```

- 변수 it의 타입은 제네릭 타입(T)이며 컴파일러는 filter의 수신 객체의 타입을 기반으로 T가 String이라는 사실을 추론함.

<br>

- 클래스나 인터페이스 안에 정의된 메서드, 확장 함수 또는 최상위 함수에서 타입 파라미터(T)를 선언할 수 있음.

```
// 제네릭 확장 프로퍼티 선언하기

val <T> List<T>.penultimate: T
  get() = this[size-2]

println(listOf(1, 2, 3, 4).penultimate)    // 3
```

- 모든 리스트 타입에 확장 프로퍼티 penultimate를 사용할 수 있음.
- 일반 (확장이 아닌) 프로퍼티는 타입 파라미터를 가질 수 없음.

<br>

### **9.1.2 제네릭 클래스 선언**

```
interface List<T> {
  operator fun get(index: Int): T
  // ...
}
```

```
// 제네릭 인터페이스를 구현하는 클래스 정의하기

class StringList<String>: List<String> {
  override fun get(index: Int): String
}

class ArrayList<T>: List<T> {
  override fun get(index: Int): T
}
```

- 제네릭 클래스를 확장하는 클래스(또는 제네릭 인터페이스를 구현하는 클래스)를 정의하려면 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 함.
  - 구체적인 타입을 넘기거나
  - 타입 파라미터로 받은 타입을 넘길 수 있음.

<br>

### **9.1.3 타입 파라미터 제약**

<br>

### **9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정**

<br>
<br>

## **리뷰**

### **느낀점**

- ...

<br>

### **보충**

- ...
