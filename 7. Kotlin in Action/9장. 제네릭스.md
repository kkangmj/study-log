# **9장. 제네릭스**

## **9.1 제네릭 타입 파라미터**

- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있음.
  ```
  // authors가 List<String> 임을 추론함.
  val authors = listOf("Dmitry", "Svetlana")
  ```
- 단, 빈 리스트를 생성하는 경우에는 컴파일러가 추론할 수 있는 근거가 없기 때문에 타입 인자를 직접 명시해야 함.
  ```
  val readers: MutableList<String> = mutableListOf()
  val readers = mutableListOf<String>()
  ```
- 자바는 뒤늦게 제네릭을 도입했기 때문에 이전 버전과의 호환성을 위해 타입 인자가 없는 제네릭 타입(raw 타입)을 허용함.
  ```
  ArrayList list = new ArrayList();    // O
  ArrayList list = new ArrayList<String>();    // O
  ```
- 그러나, 코틀린은 처음부터 제네릭을 도입했기 때문에 로 타입을 지원하지 않고 제네릭 타입의 타입 인자를 항상 정의해야 함.
  ```
  val list = mutableListOf()    // X
  val list = mutableListOf<String>()    // O
  ```

### **9.1.1 제네릭 함수와 프로퍼티**

```
fun <T> List<T>.slice(indices: IntRange): List<T>
```

- 함수의 타입 파라미터 T가 수신 객체와 반환 타입에 사용됨.

```
// 제네릭 함수 호출하기

val letters = ('a'..'z').toList()
println(letters.slice<Char>(0..2))    // [a, b, c]
println(letters.slice(10..13))    // [k, l m, n]
```

- 타입 인자를 명시적으로 지정할 수 있음. 그러나 컴파일러가 대부분 타입 인자를 추론할 수 있으므로 굳이 지정하지 않아도 됨.
- 컴파일러는 slice 함수의 반환 타입 List\<T>의 T를 자신이 추론한 Char로 치환함.

```
// 제네릭 고차 함수 호출하기

val authors = listOf("Dmitry", "Svetlana")
val readers = mutableListOf<String>(...)

fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>

readers.filter { it !in authors }
```

- 변수 it의 타입은 제네릭 타입(T)이며 컴파일러는 filter의 수신 객체의 타입을 기반으로 T가 String이라는 사실을 추론함.

<br>

- 클래스나 인터페이스 안에 정의된 메서드, 확장 함수 또는 최상위 함수에서 타입 파라미터(T)를 선언할 수 있음.

```
// 제네릭 확장 프로퍼티 선언하기

val <T> List<T>.penultimate: T
  get() = this[size-2]

println(listOf(1, 2, 3, 4).penultimate)    // 3
```

- 모든 리스트 타입에 확장 프로퍼티 penultimate를 사용할 수 있음.
- 일반 (확장이 아닌) 프로퍼티는 타입 파라미터를 가질 수 없음.

<br>

### **9.1.2 제네릭 클래스 선언**

```
interface List<T> {
  operator fun get(index: Int): T
  // ...
}
```

```
// 제네릭 인터페이스를 구현하는 클래스 정의하기

class StringList<String>: List<String> {
  override fun get(index: Int): String
}

class ArrayList<T>: List<T> {
  override fun get(index: Int): T
}
```

- 제네릭 클래스를 확장하는 클래스(또는 제네릭 인터페이스를 구현하는 클래스)를 정의하려면 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 함.
  - 구체적인 타입을 넘기거나
  - 타입 파라미터로 받은 타입을 넘길 수 있음.

<br>

### **9.1.3 타입 파라미터 제약**

- 타입 파라미터 제약
  - 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능

```
/* KOTLIN */
fun <T: Number> List<T>.sum(): T

/* JAVA */
public <T extends Number> T sum(List<T> list)
```

- 코틀린에서는 타입 파라미터 뒤에 콜론(:)을 표시하고 그 뒤에 상한 타입을 지정함으로써 제약을 정의할 수 있음.

```
fun <T: Number> oneHalf(value: T): Double {
  return value.toDouble() / 2.0
}

println(oneHalf(3))    // 1.5
```

- 타입 파라미터 T에 대한 상한을 정하고 나면 T 타입의 값을 그 상한 타입의 값으로 취급할 수 있음.
  - 위 예제에서는 상한 타입(Number)에 정의된 메서드를 호출함.

```
fun <T: Comparable<T>> max(first: T, second: T): T {
  return if (first > second) first else second
}

println(max("kotlin", "java"))    // kotlin
```

- String이 Comparable\<String>을 확장하므로 String은 max에 적합한 타입 인자임.

```
// 타입 파라미터에 여러 제약 가하기

fun <T> ensureTrailingPeriod(seq: T) where T: CharSequence, T: Appendable {
  if (!seq.endsWith('.')) {
    seq.append('.')
  }
}

val helloWorld = StringBuilder("Hello World")
ensureTrailingPeriod(helloWorld)
println(helloWorld)    // Hello World.
```

- 타입 인자(T)가 CharSequence와 Appendable 인터페이스를 반드시 구현해야 함.

<br>

### **9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정**

```
class Processor<T> {
  fun process(value: T) {
    value?.hashCode()
  }
}

val nullableStringProcessor = Processor<String?>()
nullableStringProcessor.process(null)
```

- 아무런 상한을 정하지 않은 타입 파라미터는 결과적으로 Any?를 상한으로 정한 파라미터와 동일함.
- 위 예제는 아무런 문제 없이 컴파일됨.

```
class Processor<T: Any> {
  fun process(value: T) {
    value.hashCode()
  }
}

val nullableStringProcessor = Processor<String?>()    // Error!
```

- <T: Any>라는 제약은 T 타입이 항상 널이 될 수 없는 타입이 되도록 보장함.

> 널 가능성을 제외한 아무런 제약도 필요 없다면 Any? 대신 Any를 상한으로 사용하라

<br>
<br>

## **9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터**

### **9.2.1 실행 시점의 제네릭: 타입 검사와 캐스트**

- 자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워짐.

```
val list1: List<String> = listOf("a")
val list2: List<Int> = listOf(1, 2)
```

- 컴파일러는 list1과 list2를 다른 타입으로 인식하지만 실행 시점에는 완전히 같은 타입(List)의 객체임.

```
if (value is List<String>) { ... }    // Error!
if (value is List<*>) { ... }    // No Problem!
```

- 타입 인자를 따로 저장하지 않기 때문에 실행 시점에 타입 인자를 검사할 수 없음.
- 스타 프로젝션(\*)을 사용하면 인자를 알 수 없는 제네릭 타입을 표현할 수 있음.
- as? 연산자
  - 어떤 값을 지정한 타입으로 캐스트하며, 캐스트가 불가하다면 null을 반환함.

```
// 제네릭 타입으로 타입 캐스팅하기

fun printSum(c: Collection<*>) {
  val intList = c as? List<Int> ?: throw IllegalArgumentException("List is expected")
  println(intList.sum())
}

println(printSum(listOf(1, 2, 3)))    // 6
println(printSum(setOf(1, 2)))    // IllegalArgumentException
println(printSum(listOf("a", "b")))    // ClassCastException
```

- as, as? 캐스팅에도 제네릭 타입을 사용할 수 있지만 실행 시점에는 제네릭 타입의 타입 인자를 알 수 없으므로 캐스팅은 항상 성공함.
  - ex) List\<String>, List\<Char> 모두 as? 캐스팅 성공함.
- setOf(1, 2)를 printSum의 인자로 넘긴 경우, 집합은 리스트가 아니므로 예외가 발생함.
- listOf("a", "b")를 printSum 인자로 넘긴 경우, as? 캐스팅이 성공하고 문자열 리스트에 대해 sum 함수가 호출됨. 그러나 String을 Number로 사용하려고 하면 ClassCastException이 발생함.

```
fun printSum(c: Collection<Int>) {
  if (c is List<Int>) {
    println(c.sum())
  }
}
```

- 위와 같이 작성하면 컴파일 시점에 is 검사를 수행함.
  <img src="https://user-images.githubusercontent.com/52561963/166659407-3eef4805-2aa1-48dd-aeec-f251a036392e.png" width="400">

<br>

### **9.2.2 실체화한 타입 파라미터를 사용한 함수 선언**

```
fun <T> isA(value: Any) = value is T    // Error!
```

- 일반적으로 제네릭 함수가 호출되어도 그 함수의 본문에서는 호출 시 쓰인 타입의 인자를 알 수 없음.

```
inline fun <reified T> isA(value: Any) = value is T

println(isA<String>("abc"))    // true
println(isA<String>(123))    // false
```

- 인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있음.

  - 타입 파라미터를 reified로 지정해야 함.

```
inline fun <reified T> Iterable<*>.filterIsInstance(): List<T> {
  val destination = mutableListOf<T>()
  for (element in this) {
    if (element is T) {
      destination.add(element)
    }
  }
  return destination
}

val items = listOf("one", 2, "three")
println(items.filterIsInstance<String>())    // [one, three]
```

- filterIsInstance 함수
  - 표준 라이브러리 함수로, 인자로 받은 컬렉션의 원소 중에서 타입 인자로 지정한 클래스의 인스턴스만을 모아서 만든 리스트를 반환함.
- 위 예제에서는 타입 인자를 실행 시점에 알 수 있음.

<img src="https://user-images.githubusercontent.com/52561963/167810035-a2cf8ed8-18b9-4a30-a37f-b852ce0b999b.png" width="400">

<img src="https://user-images.githubusercontent.com/52561963/167810629-44ffc95a-e5bf-47fb-8ea0-212aad30807f.png" width="400">

- 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입함. 이때 컴파일러는 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성함.
  <br>➡️ 타입 파라미터가 아닌 구체적인 타입을 사용하므로 실행 시점에 벌어지는 타입 소거의 영향을 받지 않음.

<br>

### **9.2.3 실체화한 타입 파라미터로 클래스 참조 대신**

```
// 표준 자바 API인 ServiceLoader 사용하기

val serviceImpl = ServiceLoader.load(Service::class.java)
```

- Service::class.java는 Service.class라는 자바 코드와 동일함. (리플렉션)

```
// 구체화한 타입 파라미터 사용하기 #1

inline fun <reified T> loadService() {
  return ServiceLoader.load(T::class.java)
}

val serviceImpl = loadService<Service>()
```

- 이전에 비해 훨씬 간결함.

```
// 구체화한 타입 파라미터를 사용하기 #2

inline fun <reified T: Activity> Context.startActivity() {
  val intent = Intent(this, T::class.java)
  startActivity(intent)
}

startActivity<DetailActivity>()
```

<br>
<br>

## **9.3 변성: 제네릭과 하위 타입**

- 변성 (variance)
  - 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념
  - ex) List\<String>, List\<Any>

### **9.3.1 변성이 있는 이유: 인자를 함수에 넘기기**

```
// 리스트의 내용을 출력하는 함수

fun printContents(list: List<Any>) {
  println(list.joinToString())
}

printContents(listOf("a", "b"))    // a, b


// 리스트의 원소를 변경하는 함수

fun addAnswer(list: MutableList<Any>) {
  list.add(42)
}

val strings = mutableListOf("a", "b")
addAnswer(strings)
println(strings.maxBy { it.length })    // 컴파일 X
```

- MutableList\<Any>가 필요한 곳에 MutableList\<String>을 넘길 수 없음.
- 어떤 함수가 리스트의 원소를 추가하거나 변경하면 타입 불일치가 생길 수 있어 List\<Any> 대신 List\<String>을 넘길 수 없음.
- 그러나, 원소의 추가나 변경이 없는 경우엔 List\<String>을 List\<Any> 대신 넘겨도 안전함.

> 함수가 읽기 전용 리스트를 받는다면 더 구체적인 타입의 원소를 갖는 리스트를 그 함수에 넘길 수 있음. 그러나 리스트가 변경 가능하다면 불가함.

> 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택하면 안전하지 못한 함수 호출을 막을 수 있음.

<br>

### **9.3.2 클래스, 타입, 하위 타입**

- 하위 타입
  - 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무런 문제가 없으면 타입 B는 타입 A의 하위 타입임.
- 상위 타입
  - A 타입이 B 타입의 하위 타입이라면 B는 A의 상위 타입임.

```kotlin
fun test(i: Int) {
  val n: Number = i    // 컴파일 O
  fun f(s: String) { ... }
  f(i)    // 컴파일 X
}
```

- 어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입하게 허용함.
- 함수에 전달하는 식의 타입이 함수 파라미터 타입의 하위 타입인 경우에만 함수 호출이 허용됨.

> 컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행함.

```kotlin
val s: String = "abc"
val t: String? = s    // 컴파일 O
```

- 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입임.

<br>

### **9.3.3 공변성: 하위 타입 관계를 유지**

- A가 B의 하위 타입일 때 Producer\<A>가 Producer\<B>의 하위 타입이면 Producer는 공변적임.
  <br>➡️ 하위 타입 관계가 유지됨.
- 코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 out을 넣어야 함.
  ```kotlin
  interface Producer<out T> {
    fun produce(): T
  }
  ```

```kotlin
// 무공변 컬렉션 역할을 하는 클래스 정의 & 사용하기

open class Animal {
  fun feed() { ... }
}

class Herd<T: Animal> {    // 타입 파라미터를 무공변으로 지정함.
  val size: Int get() = ...
  operator fun get(i: Int): T { ... }
}

fun feedAll(animals: Herd<Animal>) {
  for (i in 0 until animal.size) {
    animals[i].feed()
  }
}

class Cat: Animal() {
  fun cleanLitter() { ... }
}

fun takeCareOfCats(cats: Herd<Cat>) {
  for (i in 0 until cats.size) {
    cats[i].cleanLitter()
    feedAll(cats)    // Error!
  }
}
```

- 타입 불일치 오류가 발생함.
  - Herd 크래스의 T 타입 파라미터에 대해 아무 변성도 지정하지 않았기 때문에 고양이 무리는 동물 무리의 하위 클래스가 아님.

```kotlin
// 공변적 컬렉션 역할을 하는 클래스 사용하기

class Herd<out T: Animal> {    // T는 공변적임.
  ...
}

fun takeCareOfCats(cats: Herd<Cat>) {
  for (i in 0 until cats.size) {
    cats[i].cleanLitter()
  }
  feedAll(cats)
}
```

- Herd 클래스는 동물을 그 클래스에 추가하거나 무리 안의 동물을 다른 동물로 변경할 수 없음.
  <br>➡️ Herd를 공변적인 클래스로 만들 수 있음.
- 타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법을 제한함.
  <br>➡️ 타입 안전성을 보장하기 위해 공변적 파라미터는 항상 아웃 위치에 있어야만 함.

<br>

- 클래스 멤버를 선언할 때 타입 파라미터를 사용할 수 있는 지점은 인과 아웃으로 나뉨.
  <img src="https://user-images.githubusercontent.com/52561963/169473566-7bab81cd-95ca-4b38-b64e-264a190e98a0.png" width="400" >
  - T라는 타입 파라미터를 선언하고 T를 사용하는 함수가 멤버로 있는 클래스에서
    - T가 함수의 반환 타입에 쓰인다면 T는 아웃 위치
    - T가 함수의 파라미터 타입에 쓰인다면 T는 인 위치

<br>

- 타입 파라미터 T에 붙은 out 키워드는 아래 두 가지를 모두 의미함.
  - 공변성: 하위 타입 관계가 유지됨.
  - 사용 제한: T를 아웃 위치에서만 사용할 수 있음.

```kotlin
interface List<out T> : Collection<T> {
  operator fun get(index: Int) : T
  ...
}
```

- List\<T> 인터페이스에는 T 타입의 원소를 반환하는 get 메서드는 있지만 리스트에 T 타입의 값을 추가하거나 리스트에 있는 기존 값을 변경하는 메서드는 없음.
  <br>➡️ List는 T에 대해 공변적임.

```kotlin
interface MutableList<T> : List<T>, MutableCollection<T> {
  override fun add(element: T) : Boolean
}
```

- MutableList\<T>를 타입 파라미터 T에 대해 공변적인 클래스로 선언할 수 X
  - b/c T가 인 위치에 쓰이기 때문임.

```kotlin
class Herd<out T: Animal>(vararg animals: T) { ... }
```

- 생성자 파라미터는 인이나 아웃 어느 쪽도 아님.
  - 변성은 코드에서 위험할 여지가 있는 메서드를 호출할 수 없게 만듦으로써 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이 없게 방지하는 역할을 함.
  - 생성자는 위험할 여지가 X

```kotlin
class Herd<T: Animal>(var leadAnimal: T, varag animals: T) { ... }
```

- 읽기 전용 프로퍼티는 아웃 위치, 변경 가능 프로퍼티는 아웃과 인 위치 모두에 해당함.
  <br>➡️ T 타입인 leadAnimal이 인 위치에 있기 때문에 T를 out으로 표시할 수 X

- 이러한 위치 규칙은 오직 외부에서 볼 수 있는 (public, protected, internal) 클래스 API에만 적용할 수 있음.
  - 변성 규칙은 클래스 외부 사용자가 클래스를 잘못 사용하는 일을 막기 위한 것이므로 클래스 내부 구현(private 메서드)에는 적용되지 x

<br>
<br>

## **리뷰**

### **느낀점**

- 자바의 제네릭 타입 소거는 왜 실행 시점에 타입을 지우도록 했을까? 무슨 이유로?
- [p.397] 코틀린 컴파일러의 신기한 점
  - 왜 Set은 안 잡고 제네릭 타입 인자만을 잡는 걸까?
    <img src="https://user-images.githubusercontent.com/52561963/166659407-3eef4805-2aa1-48dd-aeec-f251a036392e.png" width="400">
- [p.398] "c가 List\<Int>인지 검사할 수 있다."에서 오타라고 생각하는 부분
  - List\<Int> -> Int
- inline으로 함수를 선언하고 타입 파라미터를 reified로 지정해야 타입 파라미터를 실행 시점에 검사할 수 있음.

  ```
  inline fun <reified T> isA(value: Any) = value is T
  ```

  - 위 예제에서 reified 없이 inline으로만 선언하면 컴파일 에러 뜸.

- [p.401] java.lang.Class 타입 인자를 파라미터로 받는 API는 언제 필요한 걸까?

<br>

### **보충**

- 자바의 제네릭 타입 소거 (Java Generic Type Ensure)
  - 컴파일 타임에만 타입에 대한 제약 조건을 적용하고, 런타임에는 타입에 대한 정보를 제거하는 프로세스
    - unbounded type(<?>, \<T>)는 Object로 교체하고, bounded type(ex. \<T extends Comparable>)은 bound type으로 교체함.
    - 타입 안정성 보존을 위해 필요하다면 type casting을 넣어주고, 확장된 제네릭 타입에서 다형성을 보존하기 위해 bridge method를 생성함.
  - Reference
    - https://jyami.tistory.com/99
    - https://devlog-wjdrbs96.tistory.com/263
    - https://woodcock.tistory.com/37
