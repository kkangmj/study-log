# **9장. 제네릭스**

## **9.1 제네릭 타입 파라미터**

- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있음.
  ```
  // authors가 List<String> 임을 추론함.
  val authors = listOf("Dmitry", "Svetlana")
  ```
- 단, 빈 리스트를 생성하는 경우에는 컴파일러가 추론할 수 있는 근거가 없기 때문에 타입 인자를 직접 명시해야 함.
  ```
  val readers: MutableList<String> = mutableListOf()
  val readers = mutableListOf<String>()
  ```
- 자바는 뒤늦게 제네릭을 도입했기 때문에 이전 버전과의 호환성을 위해 타입 인자가 없는 제네릭 타입(raw 타입)을 허용함.
  ```
  ArrayList list = new ArrayList();    // O
  ArrayList list = new ArrayList<String>();    // O
  ```
- 그러나, 코틀린은 처음부터 제네릭을 도입했기 때문에 로 타입을 지원하지 않고 제네릭 타입의 타입 인자를 항상 정의해야 함.
  ```
  val list = mutableListOf()    // X
  val list = mutableListOf<String>()    // O
  ```

### **9.1.1 제네릭 함수와 프로퍼티**

```
fun <T> List<T>.slice(indices: IntRange): List<T>
```

- 함수의 타입 파라미터 T가 수신 객체와 반환 타입에 사용됨.

```
// 제네릭 함수 호출하기

val letters = ('a'..'z').toList()
println(letters.slice<Char>(0..2))    // [a, b, c]
println(letters.slice(10..13))    // [k, l m, n]
```

- 타입 인자를 명시적으로 지정할 수 있음. 그러나 컴파일러가 대부분 타입 인자를 추론할 수 있으므로 굳이 지정하지 않아도 됨.
- 컴파일러는 slice 함수의 반환 타입 List\<T>의 T를 자신이 추론한 Char로 치환함.

```
// 제네릭 고차 함수 호출하기

val authors = listOf("Dmitry", "Svetlana")
val readers = mutableListOf<String>(...)

fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>

readers.filter { it !in authors }
```

- 변수 it의 타입은 제네릭 타입(T)이며 컴파일러는 filter의 수신 객체의 타입을 기반으로 T가 String이라는 사실을 추론함.

<br>

- 클래스나 인터페이스 안에 정의된 메서드, 확장 함수 또는 최상위 함수에서 타입 파라미터(T)를 선언할 수 있음.

```
// 제네릭 확장 프로퍼티 선언하기

val <T> List<T>.penultimate: T
  get() = this[size-2]

println(listOf(1, 2, 3, 4).penultimate)    // 3
```

- 모든 리스트 타입에 확장 프로퍼티 penultimate를 사용할 수 있음.
- 일반 (확장이 아닌) 프로퍼티는 타입 파라미터를 가질 수 없음.

<br>

### **9.1.2 제네릭 클래스 선언**

```
interface List<T> {
  operator fun get(index: Int): T
  // ...
}
```

```
// 제네릭 인터페이스를 구현하는 클래스 정의하기

class StringList<String>: List<String> {
  override fun get(index: Int): String
}

class ArrayList<T>: List<T> {
  override fun get(index: Int): T
}
```

- 제네릭 클래스를 확장하는 클래스(또는 제네릭 인터페이스를 구현하는 클래스)를 정의하려면 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 함.
  - 구체적인 타입을 넘기거나
  - 타입 파라미터로 받은 타입을 넘길 수 있음.

<br>

### **9.1.3 타입 파라미터 제약**

- 타입 파라미터 제약
  - 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능

```
/* KOTLIN */
fun <T: Number> List<T>.sum(): T

/* JAVA */
public <T extends Number> T sum(List<T> list)
```

- 코틀린에서는 타입 파라미터 뒤에 콜론(:)을 표시하고 그 뒤에 상한 타입을 지정함으로써 제약을 정의할 수 있음.

```
fun <T: Number> oneHalf(value: T): Double {
  return value.toDouble() / 2.0
}

println(oneHalf(3))    // 1.5
```

- 타입 파라미터 T에 대한 상한을 정하고 나면 T 타입의 값을 그 상한 타입의 값으로 취급할 수 있음.
  - 위 예제에서는 상한 타입(Number)에 정의된 메서드를 호출함.

```
fun <T: Comparable<T>> max(first: T, second: T): T {
  return if (first > second) first else second
}

println(max("kotlin", "java"))    // kotlin
```

- String이 Comparable\<String>을 확장하므로 String은 max에 적합한 타입 인자임.

```
// 타입 파라미터에 여러 제약 가하기

fun <T> ensureTrailingPeriod(seq: T) where T: CharSequence, T: Appendable {
  if (!seq.endsWith('.')) {
    seq.append('.')
  }
}

val helloWorld = StringBuilder("Hello World")
ensureTrailingPeriod(helloWorld)
println(helloWorld)    // Hello World.
```

- 타입 인자(T)가 CharSequence와 Appendable 인터페이스를 반드시 구현해야 함.

<br>

### **9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정**

```
class Processor<T> {
  fun process(value: T) {
    value?.hashCode()
  }
}

val nullableStringProcessor = Processor<String?>()
nullableStringProcessor.process(null)
```

- 아무런 상한을 정하지 않은 타입 파라미터는 결과적으로 Any?를 상한으로 정한 파라미터와 동일함.
- 위 예제는 아무런 문제 없이 컴파일됨.

```
class Processor<T: Any> {
  fun process(value: T) {
    value.hashCode()
  }
}

val nullableStringProcessor = Processor<String?>()    // Error!
```

- <T: Any>라는 제약은 T 타입이 항상 널이 될 수 없는 타입이 되도록 보장함.

> 널 가능성을 제외한 아무런 제약도 필요 없다면 Any? 대신 Any를 상한으로 사용하라

<br>
<br>

## **9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터**

### **9.2.1 실행 시점의 제네릭: 타입 검사와 캐스트**

- 자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워짐.

```
val list1: List<String> = listOf("a")
val list2: List<Int> = listOf(1, 2)
```

- 컴파일러는 list1과 list2를 다른 타입으로 인식하지만 실행 시점에는 완전히 같은 타입(List)의 객체임.

```
if (value is List<String>) { ... }    // Error!
if (value is List<*>) { ... }    // No Problem!
```

- 타입 인자를 따로 저장하지 않기 때문에 실행 시점에 타입 인자를 검사할 수 없음.
- 스타 프로젝션(\*)을 사용하면 인자를 알 수 없는 제네릭 타입을 표현할 수 있음.
- as? 연산자
  - 어떤 값을 지정한 타입으로 캐스트하며, 캐스트가 불가하다면 null을 반환함.

```
// 제네릭 타입으로 타입 캐스팅하기

fun printSum(c: Collection<*>) {
  val intList = c as? List<Int> ?: throw IllegalArgumentException("List is expected")
  println(intList.sum())
}

println(printSum(listOf(1, 2, 3)))    // 6
println(printSum(setOf(1, 2)))    // IllegalArgumentException
println(printSum(listOf("a", "b")))    // ClassCastException
```

- as, as? 캐스팅에도 제네릭 타입을 사용할 수 있지만 실행 시점에는 제네릭 타입의 타입 인자를 알 수 없으므로 캐스팅은 항상 성공함.
  - ex) List\<String>, List\<Char> 모두 as? 캐스팅 성공함.
- setOf(1, 2)를 printSum의 인자로 넘긴 경우, 집합은 리스트가 아니므로 예외가 발생함.
- listOf("a", "b")를 printSum 인자로 넘긴 경우, as? 캐스팅이 성공하고 문자열 리스트에 대해 sum 함수가 호출됨. 그러나 String을 Number로 사용하려고 하면 ClassCastException이 발생함.

```
fun printSum(c: Collection<Int>) {
  if (c is List<Int>) {
    println(c.sum())
  }
}
```

- 위와 같이 작성하면 컴파일 시점에 is 검사를 수행함.
  <img src="https://user-images.githubusercontent.com/52561963/166659407-3eef4805-2aa1-48dd-aeec-f251a036392e.png" width="400">

<br>

### **9.2.2 실체화한 타입 파라미터를 사용한 함수 선언**

<br>

### **9.2.3 실체화한 타입 파라미터로 클래스 참조 대신**

<br>

### **9.2.4 실체화한 타입 파라미터의 제약**

<br>
<br>

## **리뷰**

### **느낀점**

- 자바의 제네릭 타입 소거는 왜 실행 시점에 타입을 지우도록 했을까? 무슨 이유로?
- [p.397] 코틀린 컴파일러의 신기한 점
  - 왜 Set은 안 잡고 제네릭 타입 인자만을 잡는 걸까?
    <img src="https://user-images.githubusercontent.com/52561963/166659407-3eef4805-2aa1-48dd-aeec-f251a036392e.png" width="400">
- [p.398] "c가 List\<Int>인지 검사할 수 있다."에서 오타라고 생각하는 부분
  - List\<Int> -> Int

<br>

### **보충**

- 자바의 제네릭 타입 소거 (Java Generic Type Ensure)
  - 컴파일 타임에만 타입에 대한 제약 조건을 적용하고, 런타임에는 타입에 대한 정보를 제거하는 프로세스
    - unbounded type(<?>, \<T>)는 Object로 교체하고, bounded type(ex. \<T extends Comparable>)은 bound type으로 교체함.
    - 타입 안정성 보존을 위해 필요하다면 type casting을 넣어주고, 확장된 제네릭 타입에서 다형성을 보존하기 위해 bridge method를 생성함.
  - Reference
    - https://jyami.tistory.com/99
    - https://devlog-wjdrbs96.tistory.com/263
    - https://woodcock.tistory.com/37
