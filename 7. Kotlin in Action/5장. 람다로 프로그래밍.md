# **5장. 람다로 프로그래밍**

- 람다 식(람다)
  - 다른 함수에 넘길 수 있는 작은 코드 조각

## **5.1 람다 식과 멤버 참조**

### **5.1.1 람다 소개: 코드 블록을 함수 인자로 넘기기**

```
/* JAVA */
// 무명 내부 클래스로 리스너 구현
button.setOnClickListener(new OnClickListener() {
  @Override
  public void onClick(View view) {
    ...
  }
})

/* KOTLIN */
// 람다로 리스너 구현
button.setOnClickListener { ... }
```

- 람다를 메서드가 하나뿐인 무명 객체 대신 사용할 수 있음.

<br>

### **5.1.2 람다와 컬렉션**

```
data class Person(val name: String, val age: Int)
```

```
// 사람들로 이뤄진 리스트에서 가장 연장자를 찾는 코드

// (1) 컬렉션을 직접 검색하는 방법
fun findTheOldest(people: List<Person>) {
  var maxAge = 0
  var theOldest: Person? = null
  for (person in people) {
    if (person.age > maxAge) {
      maxAge = person.age
      theOldest = person
    }
  }
  println(theOldest)
}

val people = listOf(Person("Alice", 23), Person("Bob", 31))
findTheOldest(people)    // Person(name=Bob, age=31)


// (2) 람다를 사용해 컬렉션 검색하는 방법
val people = listOf(Person("Alice", 23), Person("Bob", 31))
println(people.maxBy { it.age })    // Person(name=Bob, age=31)
```

- 모든 컬렉션에 대해 maxBy 함수를 호출할 수 있음.
- maxBy 함수는 가장 큰 원소를 찾기 위해 사용할 값을 돌려주는 함수를 인자로 받음.

```
// (3) 멤버 참조를 사용해 컬렉션 검색하는 방법
people.maxBy(Person::age)
```

- 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치할 수 있음.

<br>

### **5.1.3 람다 식의 문법**

```
{ x: Int, y: Int -> x + y }
```

- 화살표 좌측은 파라미터, 우측은 본문

```
// 람다 식을 변수에 저장 후 호출

val sum = { x: Int, y: Int -> x + y }
println(sum(1, 2))    // 3
```

```
// 람다 식 직접 호출

run { println(42) }    // 42
```

- run
  - 인자로 받은 람다를 실행해주는 라이브러리 함수

```
val people = listOf(Person("Alice", 23), Person("Bob", 31))
println(people.maxBy { it.age })    // Person(name=Bob, age=31)
```

```
// 코틀린이 코드를 줄여 쓸 수 있게 제공했던 기능을 제거하고 정식으로 람다를 작성

people.maxBy({ p: Person -> p.age })
```

```
// 개선 작업 #1 (중괄호)

people.maxBy() { p: Person -> p.age }
people.maxBy { p: Person -> p.age }
```

- 코틀린에서는 함수 호출 시 맨 뒤에 있는 인자가 람다 식이라면 그 람다를 괄호 밖으로 빼낼 수 있음.
- 또한, 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시 괄호를 없애도 됨.

```
// 개선 작업 #2 (파라미터 타입)

people.maxBy { p: Person -> p.age }
people.maxBy { p -> p.age }
```

- 로컬 변수처럼 컴파일러는 람다 파라미터의 타입도 추론할 수 있기 때문에 파라미터 타입을 명시할 필요가 없음.

```
// 개선 작업 #3 (파라미터 이름)

people.maxBy { p -> p.age }
people.maxBy { it.age }
```

- 람다 파라미터 이름을 따로 지정하지 않은 경우에만 it이 자동으로 생성됨. 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있다면 it을 바로 쓸 수 있음.

```
// 람다를 변수에 저장할 때는 파라미터 타입을 명시해야 함.

val getAge = { p: Person -> p.age }
people.maxBy(getAge)
```

```
// 본문이 여러 줄로 이루어진 람다

val sum = { x: Int, y: Int ->
  println("Computing the sum of $x and $y...")
  x + y
  }
println(sum(1, 2))    // Computing the sum of 1 and 2...
                      // 3
```

- 본문의 맨 마지막에 있는 식이 람다의 결과 값이 됨.

<br>

### **5.1.4 현재 영역에 있는 변수에 접근**

- 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용 가능함.

```
// 함수 파라미터를 람다 안에서 사용하기

fun printMessagesWithPrefix(messages: Collection<String>, prefix: String) {
  messages.forEach {
    println("$prefix $it")
  }
}

val errors = listOf("403 Forbidden", "404 Not Found")
printMessagesWithPrefix(errors, "Error:")    // Error: 403 Forbidden
                                             // Error: 404 Not Found
```

- forEach는 컬렉션의 모든 원소에 대해 람다를 호출해줌.

```
fun printProblemCounts(responses: Collection<String>) {
  var clientErrors = 0
  var serverErrors = 0
  responses.forEach {
    if (it.startsWith("4")) {
      clientErrors++
    } else if (it.startsWith("5")) {
      serverErrors++
    }
  }
  println("$clientErrors client errors, $serverErrors server errors")
}

val responses = listOf("200 OK", "418 I'm a teapot", "500 Internal Server Error")
println(printProblemCounts(responses))    // 1 client errors, 1 server errors
```

- 코틀린에서는 자바와 달리 람다에서 람다 밖 함수에 있는 파이널이 아닌 변수에 접근할 수 있고, 그 변수를 변경할 수도 있음.
- 람다가 포획한 변수
  - 위 예제의 prefix, clientErrors, serverErrors와 같이 람다 안에서 사용하는 외부 변수
- 포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행하면 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있음.
  - b/c 파이널이 아닌 변수를 포획한 경우에는 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장함. 파이널 변수를 포획한 경우에는 람다 코드를 변수 값과 함께 저장함.

```
// 변수 포획의 구현 방법

class Ref<T>(var value: T)
val counter = Ref(0)
val inc = { counter.value++ }

var counter = 0
val inc = { counter++ }
```

- 람다가 변경 가능한 변수(var)를 포획하면 변수를 Ref 클래스 안에 넣음. 그 Ref 인스턴스에 대한 참조를 파이널로 만들면 람다로 포획할 수 있고, 람다 안에서는 Ref 인스턴스의 필드를 변경할 수 있음.

<br>

### **5.1.5 멤버 참조**

```
val getAge = { person: Person -> person.age }

val getAge = { Person::age }
```

- 멤버 참조는 프로퍼티나 메서드를 단 하나만 호출하는 함수 값을 만들어줌.
- 이중콜론(::)은 클래스 이름과 참조하려는 멤버(프로퍼티나 메서드) 이름 사이에 위치함.

```
// 생성자 참조

data class Person(val name: String, val age: Int)
val createPerson = ::Person
val p = createPerson("Amy", 22)
println(p)    // Person(name=Amy, age=22)
```

- Person의 인스턴스를 만드는 동작을 값으로 저장함.

```
// 바운드 멤버 참조

val p = Person("D", 34)
val personAgeFunction = Person::age
println(personAgeFunction(p))    // 34

val dAgeFunction = p::age    // 바운드 멤버 참조
println(dAgeFunction())    // 34
```

- 바운드 멤버 참조를 사용하면 멤버 참조를 생성할 때 클래스 인스턴스를 함께 저장한 다음 나중에 그 인스턴스에 대한 멤버를 호출해줌.

<br>
<br>

## **리뷰**

### **느낀점**

- 람다에서 외부 변수를 사용할 수 있다는 차이점이 새로웠음.
- p.208에 옮긴이 주석이 있는데 이해가 안 감...

<br>

### **보충**

- 자바에서 익명 클래스와 람다

  ```
  // 익명 클래스

  Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
  	  return Integer.compare(s1.length(), s2.length());
    }
  });
  ```

  ```
  // 람다

  Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()))
  ```

  - https://nettle-yellowhorn-6b9.notion.site/2021-05-16-9-645e713e002c4bb69290e9156bb81885
