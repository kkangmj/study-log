# **TIL (2022.02.16)**

## DAY 2 & DAY 3

🎇 오늘 읽은 범위: (11장) 시스템

```
😀 책에서 기억하고 싶은 내용을 써보세요
```

- **시스템 제작과 시스템 사용을 분리하라**
  <br>

  > 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 함.

  ```
  // 객체 생성 로직과 런타임 로직이 섞인 예
  // 초기화 지연 기법

  public Service getService() {
      if (service == null)
        service = new MyServiceImpl(...);
      return service;
  }
  ```

  - 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아짐. 또한, 주요 의존성을 해소하기 위한 방식, 즉 전반적이며 일관적인 방식도 필요함.
  - 시스템 생성과 사용을 분리하는 방법
    1. main 분리
    2. 팩토리
    3. 의존성 주입

<br>

- **확장**
  - '처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신임.
  - 대신 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현하고 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 됨.
  - TDD, 리팩터링, 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만듦.
  - 소프트웨어 시스템은 물리적인 시스템과 다름. 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있음.

<br>

- **AspectJ 관점**
  - 관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ 언어임.
    - AspectJ는 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장임.

<br>

- **테스트 주도 시스템 아키텍처 구축**

  - 애플리케이션 도메인 논리를 POJO로 작성할 수 있다면, 즉 코드 수준에서 아키텍처 관심을 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해짐.

    > 최선의 시스템 구조는 각기 POJO (또는 다른) 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다. 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다. 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.

<br>

- **의사 결정을 최적화하라**
  - 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해짐.
    > 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공한다. 이런 기민함 덕택에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기가 쉬워진다. 또한 결정의 복잡성도 줄어든다.

<br>

- **명백한 가치가 있을 때 표준을 현명하게 사용하라**

<br>

- **시스템은 도메인 특화 언어가 필요하다**
  - 좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 '의사소통 간극'을 줄여줌.
    > 도메인 특화 언어(DSL)를 사용하면 고차원 정책에서 저차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현할 수 있다.

<br>

- 시스템 역시 깨끗해야 한다. 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다.
- 모든 추상화 단계에서 의도는 명확히 표현해야 한다. 그러려면 POJO를 작성하고 관점 혹은 관점과 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야 한다.

<br>

```
🤔 오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요
```

- 중간 부분은 이해가 되지 않아 이해할 수 있는 부분만 읽으며 넘어갔다. 자바와 스프링을 공부하고 있는 취준생으로써 다시 한 번 공부는 끝이 없다는 사실을 깨달았다. 이 장에서 이해하지 못한 파트는 나중에 다시 읽어보는 게 좋을 것 같다.
- 테스트 주도 시스템 아키텍처 구축 파트에서 '애플리케이션 도메인 논리를 POJO로 작성할 수 있다면 진정한 테스트 주도 아키텍처 구축이 가능해진다'라고 했는데, 애플리케이션 논리와 이를 POJO로 작성한 예시가 있었다면 이해가 명확했을 것 같다.

<br>

```
🔍 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요
```

- 지연 초기화(lazy initailization) [이펙티브 자바]
  - 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법
  - 값이 전혀 쓰이지 않으면 초기화도 결코 일어나지 않음.
  - 클래스 혹은 인스턴스 생성 시 초기화 비용은 줄지만 대신 지연 초기화하는 필드에 접근하는 비용은 커짐. 또한, 지연 초기화하려는 필드들 중 초기화가 이뤄지는 비율에 따라, 실제 초기화에 드는 비용에 따라, 초기화된 각 필드를 얼마나 빈번히 호출하느냐에 따라 지연 초기화가 성능을 느려지게 할 수 있음.
    > 대부분의 상황에서는 일반적인 초기화가 지연 초기화보다 낫다.

<br>

- [p.195] 런타임 로직에서 MyServiceImpl 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않는다면 컴파일이 안 된다.
  - 여기서 말하는 "해결"의 의미는 무엇인지?

<br>

- 추상 팩토리 패턴(abstract factory pattern)
  - https://victorydntmd.tistory.com/300

<br>

- 확장 파트의 예제, 자바 프록시, 순수 자바 AOP 프레임워크 파트는 전혀 이해하지 못함.
