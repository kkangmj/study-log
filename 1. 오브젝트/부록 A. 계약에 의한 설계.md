# **부록 A. 계약에 의한 설계**

## **3. 계약에 의한 설계와 서브타이핑**

- 리스코프 치환 원칙은 슈퍼타입의 인스턴스와 협력하는 클라이언트의 관점에서 서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것을 의미함.
  <br>
  ➡️ 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 함.
  <br>

- 리스코프 치환 원칙의 규칙 2가지
  <br>
  1. 계약 규칙
     - 슈퍼타입과 서브타입 사이의 사전조건, 사후조건, 불변식에 대해 서술할 수 있는 제약에 관한 규칙
  2. 가변성 규칙
     - 파라미터와 리턴 타입의 변형과 관련된 규칙

<br>

- 계약에 의한 설계가 특정 라이브러리나 프레임워크와는 상관 없는 설계 개념임. 비록 계약에 의한 설계를 위한 적절한 라이브러리가 존재하지 않거나 언어 차원에서 지원하지 않는다고 하더라도 계약에 의한 설계를 적용하는 것은 가능함.
  <br>

- 계약 규칙

  - 서브타입에 더 강력한 사전조건을 정의할 수 없다.
    - 서브타입이 슈퍼타입에 정의된 사전조건을 강화하면 기존에 체결된 계약을 위반하게 된다. 결국 사전조건을 강화한 서브타입은 클라이언트 입장에서 수용이 불가능하기 때문에 슈퍼타입을 대체할 수 없다.
  - 서브타입에 더 완화된 사후조건을 정의할 수 없다.
    - 사후조건을 완화시키는 서버는 클라이언트 관점에서 수용할 수 없기 때문에 슈퍼타입을 대체할 수 없다.
  - 슈퍼타입의 불변식은 서브타입에서도 반드시 유지되어야 한다.
    - protected 인스턴스 변수를 가진 부모 클래스의 불변성은 자식 클래스에 의해 언제라도 쉽게 무너질 수 있다. 모든 인스턴스 변수의 가시성은 private로 제한해야 한다.
  - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.

- 가변성 규칙

  - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 된다.

    - 일반적으로 부모 클래스가 던지는 예외가 속한 상속 계층이 아닌 다른 상속 계층에 속하는 예외를 던질 경우, 자식 클래스는 부모 클래스를 대체할 수 없음.
    - 클라이언트 관점에서 부모 클래스에 대해 기대했던 것보다 더 적은 일을 수행하는 자식 클래스는 부모 클래스와 동일하지 않음.

  - 서브타입의 리턴 타입은 공변성을 가져야 한다.

    ```
    public class Publisher {}
    public class IndependentPublisher extends Publisher{}

    public class Book {}
    public class Magazine extends Book {}

    public class BookStall {
      public Book sell(IndependentPublisher independentPublisher) {
        return new Book(independentPublisher);
      }
    }
    public class MagazineStore extends BookStall {
      @Override
      public Book sell(IndependentPublisher independentPublisher) {
        return new Magazine(independentPublisher);
      }
    }
    public class Customer {
      private Book book;
      public void order(BookStall bookStall) {
        this.book = bookStall.sell(new IndependentPublisher());
      }
    }
    ```

    - 리턴 타입 공변성은 메서드의 구현 계층과 리턴 타입의 계층이 동일한 방향을 가짐.
    - <span style="color: yellow">슈퍼타입 대신 서브타입을 반환하는 것은 더 강력한 사후조건을 정의하는 것과 같음.</span>
    - 메서드를 구현한 슈퍼타입(BookStall)이 리턴값의 슈퍼타입(Book)을 반환할 경우 메서드를 오버라이딩하는 서브타입(MagazineStore)이 슈퍼타입에서 사용한 리턴 타입의 서브타입을 리턴 타입으로 사용하더라도 클라이언트 입장(Customer)에서 대체 가능함.

  - 서브타입의 메서드 파라미터는 반공변성을 가져야 한다.
    - 파라미터 타입 반공변성은 메서드를 정의한 클래스의 타입 계층과 파라미터의 타입 계층 방향이 반대임.
    - <span style="color: yellow">서브타입 대신 슈퍼타입을 파라미터로 받는 것은 더 약한 사전조건을 정의하는 것과 같음.</span>
    - 메서드를 구현한 슈퍼타입(BookStall)이 어떤 서브타입(IndependentPublisher)을 파라미터로 받을 경우 메서드를 오버라이딩하는 서브타입(MagazineStore)이 슈퍼타입에서 사용한 파라미터 타입의 슈퍼타입(Publisher)을 파라미터 타입으로 사용하더라도 클라이언트 입장(Customer)에서 대체 가능함.
    - 단, 자바에서는 파라미터 반공변성을 허용하지 않음.

- S가 T의 서브타입

  - 공변성
    - S와 T의 서브타입 관계가 그대로 유지됨. 이 경우 해당 위치에서 서브타입인 S가 슈퍼타입 T 대신 사용될 수 있음.
  - 반공변성
    - S와 T 사이의 서브타입 관계가 역전됨. 이 경우 해당 위치에서 슈퍼타입인 T가 S 대신 사용될 수 있음.
  - 무공변성
    - S와 T 사이에 아무런 관계가 없음.
      <br>

- 일찍 실패하기(Fail Fast)
  - 문제가 발생한 그 위치에서 프로그램이 실패하도록 만들어라. 문제의 원인을 파악할 수 있는 가장 빠른 방법은 문제가 발생하자마자 프로그램이 일찍 실패하게 만드는 것이다.

---

- controller 단에서 Request Body의 유효성 검사를 위해 정의한 Dto가 결국 사전조건이고, controller의 리턴타입을 "넓게" 보면 사후조건이라고 할 수 있지 않을까? 왜냐하면 계약에 의한 설계는 특정 라이브러리나 프레임워크와 상관 없는 "개념"이니까.

---

- <span style="color: yellow">서브타입이 슈퍼타입을 치환할 수 있다는 것은 계약에 의한 설계에서 정의한 계약 규칙과 가변성 규칙을 준수하는 것을 의미함. </span>
