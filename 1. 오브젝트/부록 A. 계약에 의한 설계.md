# **부록 A. 계약에 의한 설계**

## **3. 계약에 의한 설계와 서브타이핑**

- 리스코프 치환 원칙은 슈퍼타입의 인스턴스와 협력하는 클라이언트의 관점에서 서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것을 의미함.
  <br>
  ➡️ 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 함.
- 리스코프 치환 원칙의 규칙 2가지
  <br>
  1. 계약 규칙
     - 슈퍼타입과 서브타입 사이의 사전조건, 사후조건, 불변식에 대해 서술할 수 있는 제약에 관한 규칙
  2. 가변성 규칙
     - 파라미터와 리턴 타입의 변형과 관련된 규칙
- 계약에 의한 설계가 특정 라이브러리나 프레임워크와는 상관 없는 설계 개념임. 비록 계약에 의한 설계를 위한 적절한 라이브러리가 존재하지 않거나 언어 차원에서 지원하지 않는다고 하더라도 계약에 의한 설계를 적용하는 것은 가능함.
- 계약 규칙
  - 서브타입에 더 강력한 사전조건을 정의할 수 없다.
    - 서브타입이 슈퍼타입에 정의된 사전조건을 강화하면 기존에 체결된 계약을 위반하게 된다. 결국 사전조건을 강화한 서브타입은 클라이언트 입장에서 수용이 불가능하기 때문에 슈퍼타입을 대체할 수 없다.
  - 서브타입에 더 완화된 사후조건을 정의할 수 없다.
    - 사후조건을 완화시키는 서버는 클라이언트 관점에서 수용할 수 없기 때문에 슈퍼타입을 대체할 수 없다.
  - 슈퍼타입의 불변식은 서브타입에서도 반드시 유지되어야 한다.
    - protected 인스턴스 변수를 가진 부모 클래스의 불변성은 자식 클래스에 의해 언제라도 쉽게 무너질 수 있다. 모든 인스턴스 변수의 가시성은 private로 제한해야 한다.
  - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.
- 가변성 규칙
- 일찍 실패하기(Fail Fast)
  - 문제가 발생한 그 위치에서 프로그램이 실패하도록 만들어라. 문제의 원인을 파악할 수 있는 가장 빠른 방법은 문제가 발생하자마자 프로그램이 일찍 실패하게 만드는 것이다.

---

- controller 단에서 Request Body의 유효성 검사를 위해 정의한 Dto가 결국 사전조건이고, controller의 리턴타입을 넓게 보면 사후조건이라고 할 수 있지 않을까? 왜냐하면 계약에 의한 설계는 특정 라이브러리나 프레임워크와 상관 없는 "개념"이니까.

---
